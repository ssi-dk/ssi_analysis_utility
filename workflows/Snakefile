import pandas as pd
import os
import yaml
from ssi_analysis_utility import convert_external_genome

# Read the CSV file
csv = config['input_manager']['path']
csv_data = pd.read_csv(csv, sep='\t')

# Setup output folder
OUT_FOLDER = config['input_manager']['out_folder']



############ Example TSV format ################:
# sample_name     Illumina_read_files     Nanopore_read_file      ...  ...       variant notes
# GAS-2022-1029   GAS-2022-1029_S42_L555_R1_001.fastq.gz,GAS-2022-1029_S42_L555_R2_001.fastq.gz   GAS-2022-1029_nanopore.fastq.gz GAS-2022-1029.fasta  

# Use the sample names as wildcards
SAMPLES = csv_data['sample_name'].tolist()

# Create a dictionary for mapping sampleID to file paths
sample_to_illumina = {row['sample_name']: row['Illumina_read_files'].split(',') for idx, row in csv_data.iterrows()}
sample_to_nanopore = {row['sample_name']: row['Nanopore_read_file'] for idx, row in csv_data.iterrows()}
sample_to_assembly_file = {row['sample_name']: row['assembly_file'] for idx, row in csv_data.iterrows()}
sample_to_organism = {row['sample_name']: row['organism'] for idx, row in csv_data.iterrows()}

#------------------------------ Modules --------------------------------#



##############################################################################
#
#                              Snakefile 
#
##############################################################################


# Define the dynamic input for rule all
rule all:
    input:
        expand("{out}/{sample}/emm_typing/", 
               sample=[s for s in SAMPLES if "emm_typing" in config["Species"][sample_to_organism[s]]["analyses_to_run"]],
               out=OUT_FOLDER),
        expand("{out}/{sample}/blast/", 
               sample=[s for s in SAMPLES if "resistance_gene_detection" in config["Species"][sample_to_organism[s]]["analyses_to_run"]],
               out=OUT_FOLDER),
        expand("{out}/{sample}/assembly_lineage/", 
               sample=[s for s in SAMPLES if "assembly_lineage_determination" in config["Species"][sample_to_organism[s]]["analyses_to_run"]],
               out=OUT_FOLDER),
        expand("{out}/{sample}/illumina_lineage/", 
               sample=[s for s in SAMPLES if "Illumina_lineage_determination" in config["Species"][sample_to_organism[s]]["analyses_to_run"]],
               out=OUT_FOLDER),
        expand("{out}/{sample}/plasmidfinder/", 
               sample=[s for s in SAMPLES if "plasmidfinder" in config["Species"][sample_to_organism[s]]["analyses_to_run"]],
               out=OUT_FOLDER),
        expand("{out}/{sample}/resfinder/", 
               sample=[s for s in SAMPLES if "resfinder" in config["Species"][sample_to_organism[s]]["analyses_to_run"]],
               out=OUT_FOLDER),
        expand("{out}/{sample}/virulencefinder/", 
               sample=[s for s in SAMPLES if "virulencefinder" in config["Species"][sample_to_organism[s]]["analyses_to_run"]],
               out=OUT_FOLDER),
        expand("{out}/{sample}/lre-finder/", 
               sample=[s for s in SAMPLES if "lre-finder" in config["Species"][sample_to_organism[s]]["analyses_to_run"]],
               out=OUT_FOLDER),
        expand("{out}/{sample}/serotypefinder/", 
               sample=[s for s in SAMPLES if "serotypefinder" in config["Species"][sample_to_organism[s]]["analyses_to_run"]],
               out=OUT_FOLDER),
        expand("{out}/{sample}/kleborate/", 
               sample=[s for s in SAMPLES if "kleborate" in config["Species"][sample_to_organism[s]]["analyses_to_run"]],
               out=OUT_FOLDER),
        expand("{out}/{sample}/chtyper/", 
               sample=[s for s in SAMPLES if "chtyper" in config["Species"][sample_to_organism[s]]["analyses_to_run"]],
               out=OUT_FOLDER),
        expand("{out}/{sample}/kmerfinder/", 
               sample=[s for s in SAMPLES if "kmerfinder" in config["Species"][sample_to_organism[s]]["analyses_to_run"]],
               out=OUT_FOLDER),
        expand("{out}/{sample}/cgmlstfinder/", 
               sample=[s for s in SAMPLES if "cgMLSTFinder" in config["Species"][sample_to_organism[s]]["analyses_to_run"]],
               out=OUT_FOLDER),


##################### BLAST AMR GENES #####################################

rule resistance_gene_detection:
    input:
        amr_genes = config["analysis_settings"]["blast_presence_absence"]["query_fasta_resistance_gene_detection"],
        assembly = lambda wildcards: sample_to_assembly_file[wildcards.sample]
    output:
        directory("{out}/{sample}/blast/")  # Indicate that the output is a directory
    shell:
        """
        if [ -d {output} ]; 
            then
                echo "Directory {output} exists,skipping."
                exit 1
            else
                mkdir {output}
        fi

        blastn -query {input.amr_genes} \
               -subject {input.assembly} \
               -out {output}/blast_output.tsv \
               -outfmt '6 qseqid sseqid pident length qlen qstart qend sstart send sseq evalue bitscore'
        """



###################### EMM TYPING #############################################


rule emm_typing:
    input:
        emm_allele_files = config["analysis_settings"]["emm_typing"]["emm_allele_file"],
        assembly = lambda wildcards: sample_to_assembly_file[wildcards.sample]
    output:
        directory("{out}/{sample}/emm_typing/")  # Indicate that the output is a directory
    shell:
        """
        if [ -d {output} ]; 
            then
                echo "Directory {output} exists,skipping."
                exit 1
            else
                mkdir {output}
        fi

        blastn -query {input.emm_allele_files} \
               -subject {input.assembly} \
               -qcov_hsp_perc 90 \
               -out {output}/blast_output.tsv \
               -outfmt '6 qseqid sseqid pident length qlen qstart qend sstart send sseq evalue bitscore'
        """


############################ ASSEMBLY LINEAGE ####################################
# Likely to add the convert_external_genome script functions as helper functions to notebook
rule assembly_lineage_determination:
    input:
        reference= config["analysis_settings"]["assembly_lineage_determination"]["reference_fasta_file"],
        assembly = lambda wildcards: sample_to_assembly_file[wildcards.sample]
    output:
        directory("{out}/{sample}/assembly_lineage/")
    params:
        name = lambda wildcards: wildcards.sample,
        deltafile= lambda wildcards: wildcards.sample + ".filtered.delta",
        frankenfasta = lambda wildcards: wildcards.sample + ".frankenfasta",
        nucmerpath=config["analysis_settings"]["assembly_lineage_determination"]["nucmerpath"],
        nucmerargs=config["analysis_settings"]["assembly_lineage_determination"]["nucmerargs"],
        deltafilterpath=config["analysis_settings"]["assembly_lineage_determination"]["deltafilterpath"],
        deltafilterargs=config["analysis_settings"]["assembly_lineage_determination"]["deltafilterargs"]
    run:
        if not os.path.exists(str(output)):
            os.mkdir(str(output))
            external_genome = convert_external_genome.Genome()
            external_genome.import_fasta_file(str(input.assembly))
            convert_external_genome.generate_delta_file(params.nucmerpath, 
                                                        params.nucmerargs, 
                                                        params.deltafilterpath,
                                                        params.deltafilterargs, 
                                                        params.name, 
                                                        input.reference,
                                                        input.assembly, 
                                                        str(output) )
            franken_genome = convert_external_genome.Genome()
            convert_external_genome.parse_delta_file((os.path.join(str(output), params.deltafile)),
                                                    franken_genome, 
                                                    external_genome)
            franken_genome.write_to_fasta_file( (os.path.join(str(output), str(params.frankenfasta))), str(params.name) + " ref:")
        else:
            print("Directory {output} exists,skipping.")
            exit() 




# # GATK 4 changed the workflow, now it is HaplotypeCaller, some options are different though #
# rule illumina_lineage:
#     input:
#         R1 = lambda wildcards: sample_to_illumina[wildcards.sample][0],
#         R2 = lambda wildcards: sample_to_illumina[wildcards.sample][1],
#         reference= config["analysis_settings"]["Illumina_lineage_determination"]["reference_fasta_file"],
#     output:
#         directory("{out}/{sample}/illumina_lineage/")
#     params:
#         name = lambda wildcards: wildcards.sample
#     shell:
#         """
#         # Set output paths
        
#         if [ -d {output} ]; 
#         then
#             echo "Directory {output} exists,skipping."
#         else
#             mkdir {output}
#         fi
    
#         bam_file="{output}/{params.name}.bam"
#         vcf_file="{output}/{params.name}.vcf"

#         # Define commands
#         bwamem_cmd="bwa mem \
#                     -R '@RG\\tID:{params.name}\\tSM:{params.name}' \
#                     -t 4 {input.reference} \
#                     {input.R1} {input.R2} \
#                     | samtools view -S -b -h - \
#                     | samtools sort -o ${{bam_file}}"

#         samtoolsindex_cmd="samtools index ${{bam_file}}"

#         gatk_cmd="java -Xmx10G \
#                     -jar GenomeAnalysisTK.jar \
#                     -T UnifiedGenotyper \
#                     -dt NONE \
#                     -glm BOTH \
#                     -I ${{bam_file}} \
#                     -R {input.reference} \
#                     -nt 4 \
#                     -o ${{vcf_file}} \
#                     -out_mode EMIT_ALL_CONFIDENT_SITES \
#                     -baq RECALCULATE \
#                     -stand_call_conf 100 \
#                     -ploidy 1"


#         # Determine the command to run
#         if [ -f "${{vcf_file}}" ]; then
#             echo "VCF file found at ${{vcf_file}}. Skipping read mapping."
#         else
#             if [ -f "${{bam_file}}" ]; then
#                 cmd="${{gatk_cmd}}"
#                 echo "Indexed BAM file found at ${{bam_file}}. Running GATK."
#             elif [ -f "${{bam_file}}" ]; then
#                 cmd="${{samtoolsindex_cmd}}; ${{gatk_cmd}}"
#                 echo "BAM file found at ${{bam_file}}. Indexing and running GATK."
#             else
#                 cmd="${{bwamem_cmd}}; ${{samtoolsindex_cmd}}; ${{gatk_cmd}}"
#                 echo "Running BWA-MEM and GATK."
#             fi

#             # Execute the determined command
#             eval "${{cmd}}"
#         fi
#         """
    


rule PlasmidFinder:
    input:
        R1 = lambda wildcards: sample_to_illumina[wildcards.sample][0],
        R2 = lambda wildcards: sample_to_illumina[wildcards.sample][1]
    params:
        db_path = config["analysis_settings"]["plasmidfinder"]["database"],
        kma_path = config["analysis_settings"]["kma_aligner"]["path"]
    output:
        directory("{out}/{sample}/plasmidfinder/")  # Indicate that the output is a directory
    shell:
        """
        if [ -d {output} ]; 
            then
                echo "Directory {output} exists,skipping."
                exit 1
            else
                mkdir {output}
        fi        
        plasmidfinder.py -i {input.R1} {input.R2} -o {output} -p {params.db_path} -mp {params.kma_path}
        """


rule ResFinder:
    input:
        R1 = lambda wildcards: sample_to_illumina[wildcards.sample][0],
        R2 = lambda wildcards: sample_to_illumina[wildcards.sample][1]
    params:
        res_db_path = config["analysis_settings"]["resfinder"]["resfinder_db"],
        point_db_path = config["analysis_settings"]["resfinder"]["pointfinder_db"],
        disi_db_path = config["analysis_settings"]["resfinder"]["disinfinder_db"]
    output:
        directory("{out}/{sample}/resfinder/")  # Indicate that the output is a directory
    shell:
        """
        if [ -d {output} ]; 
            then
                echo "Directory {output} exists,skipping."
                exit 1
            else
                mkdir {output}
        fi        
        # Example command using input fastq files
        python -m resfinder -ifq {input.R1} {input.R2} -o {output} -db_res {params.res_db_path} -db_disinf {params.disi_db_path} -db_point {params.point_db_path} -acq
        """



rule VirulenceFinder:
    input:
        R1 = lambda wildcards: sample_to_illumina[wildcards.sample][0],
        R2 = lambda wildcards: sample_to_illumina[wildcards.sample][1]
    params:
        db_path = config["analysis_settings"]["virulencefinder"]["database"],
        kma_path = config["analysis_settings"]["kma_aligner"]["path"]
    output:
        directory("{out}/{sample}/virulencefinder/")  # Indicate that the output is a directory
    shell:
        """
        if [ -d {output} ]; 
            then
                echo "Directory {output} exists,skipping."
                exit 1
            else
                mkdir {output}
        fi 

        virulencefinder.py -i {input.R1} {input.R2} -o {output} -p {params.db_path} -mp {params.kma_path}
        """

rule LREFinder:
    input:
        R1 = lambda wildcards: sample_to_illumina[wildcards.sample][0],
        R2 = lambda wildcards: sample_to_illumina[wildcards.sample][1]
    params:
        db_path = config["analysis_settings"]["LRE-finder"]["database"],
        app_path = config["analysis_settings"]["LRE-finder"]["path"]
    output:
        directory("{out}/{sample}/lre-finder/")  # Indicate that the output is a directory
    shell:
        """
        if [ -d {output} ]; 
            then
                echo "Directory {output} exists, skipping."
                exit 1
            else
                mkdir {output}
                cd {output}
        fi 
        python {params.app_path}/LRE-Finder.py -ipe {input.R1} {input.R2} -o lre-finder -t_db {params.db_path} -ID 80 -1t1 -cge -matrix
        """


rule serotypefinder:
    input:
        R1 = lambda wildcards: sample_to_illumina[wildcards.sample][0],
        R2 = lambda wildcards: sample_to_illumina[wildcards.sample][1]
    params:
        db_path = config["analysis_settings"]["serotypefinder"]["database"],
    output:
        directory("{out}/{sample}/serotypefinder/")  # Indicate that the output is a directory
    shell:
        """
        if [ -d {output} ]; 
            then
                echo "Directory {output} exists, skipping."
                exit 1
            else
                mkdir {output}
        fi 
        serotypefinder -i {input.R1} {input.R2} -o {output} -p {params.db_path} 
        """

rule kleborate:
    input:
        assembly = lambda wildcards: sample_to_assembly_file[wildcards.sample]
    params:
        preset = config["analysis_settings"]["kleborate"]["preset"],
    output:
        directory("{out}/{sample}/kleborate/")  # Indicate that the output is a directory
    shell:
        """
        if [ -d {output} ]; 
            then
                echo "Directory {output} exists, skipping."
                exit 1
            else
                mkdir {output}
        fi 
        kleborate -a {input.assembly}  -o {output} -p {params.preset} 
        """


rule CHtyper:
    input:
        assembly = lambda wildcards: sample_to_assembly_file[wildcards.sample]
    params:
        app_path = config["analysis_settings"]["chtyper"]["path"],
        database = config["analysis_settings"]["chtyper"]["database"],
        threshold = config["analysis_settings"]["chtyper"]["threshold"],
        coverage = config["analysis_settings"]["chtyper"]["coverage"],
        blast = config["analysis_settings"]["chtyper"]["blast"]
    output:
        directory("{out}/{sample}/chtyper/")  # Indicate that the output is a directory
    shell:
        """
        if [ -d {output} ]; 
            then
                echo "Directory {output} exists, skipping."
                exit 1
            else
                mkdir {output}
        fi 
        python {params.app_path}/CHTyper-1.0.py -i {input.assembly}  -o {output} -p {params.database} -t {params.threshold} -l {params.coverage} -b {params.blast}
        """

rule kmerfinder:
    input:
        R1 = lambda wildcards: sample_to_illumina[wildcards.sample][0],
        R2 = lambda wildcards: sample_to_illumina[wildcards.sample][1]
    params:
        db_path = config["analysis_settings"]["kmerfinder"]["database"],
        kma_path = config["analysis_settings"]["kma_aligner"]["path"],
        taxa = config["analysis_settings"]["kmerfinder"]["taxa"]
    output:
        directory("{out}/{sample}/kmerfinder/")  # Indicate that the output is a directory
    shell:
        """
        if [ -d {output} ]; 
            then
                echo "Directory {output} exists, skipping."
                exit 1
            else
                mkdir {output}
        fi 
        kmerfinder.py  -i {input.R1} {input.R2} -o {output} -db {params.db_path} -tax {params.taxa}
        """

rule cgMLSTFinder:
    input:
        R1 = lambda wildcards: sample_to_illumina[wildcards.sample][0],
        R2 = lambda wildcards: sample_to_illumina[wildcards.sample][1]
    params:
        app_path = config["analysis_settings"]["cgMLSTFinder"]["path"],
        db_path = config["analysis_settings"]["cgMLSTFinder"]["database"],
        scheme = config["analysis_settings"]["cgMLSTFinder"]["scheme"],
        kma_path = config["analysis_settings"]["kma_aligner"]["path"]
    output:
        directory("{out}/{sample}/cgmlstfinder/")  # Indicate that the output is a directory
    shell:
        """
        if [ -d {output} ]; 
            then
                echo "Directory {output} exists, skipping."
                exit 1
            else
                mkdir {output}
        fi 
        python {params.app_path}/cgMLST.py  -i {input.R1},{input.R2} -o {output} -db {params.db_path} -k {params.kma_path} -s {params.scheme}
        """